Discovery messages 
Discovery topic 
The discovery topic needs to follow a specific format:

<discovery_prefix>/<component>/[<node_id>/]<object_id>/config
Text
<discovery_prefix>: The Discovery Prefix defaults to homeassistant and this prefix can be changed.
<component>: One of the supported MQTT integrations, e.g., binary_sensor, or device in case of a device discovery.
<node_id>: (Optional): ID of the node providing the topic, this is not used by Home Assistant but may be used to structure the MQTT topic. The ID of the node must only consist of characters from the character class [a-zA-Z0-9_-] (alphanumerics, underscore and hyphen).
<object_id>: The ID of the device. This is only to allow for separate topics for each device and is not used for the entity_id. The ID of the device must only consist of characters from the character class [a-zA-Z0-9_-] (alphanumerics, underscore and hyphen).
The <node_id> level can be used by clients to only subscribe to their own (command) topics by using one wildcard topic like <discovery_prefix>/+/<node_id>/+/set.

Best practice for entities with a unique_id is to set <object_id> to unique_id and omit the <node_id>.

Device discovery payload 
A device can send a discovery payload to expose all components for a device. The <component> part in the discovery topic must be set to device.

As an alternative, it is also possible a device can send a discovery payload for each component it wants to set up.

The shared options at the root level of the JSON message must include:

device mapping (abbreviated as dev)
origin mapping (abbreviated as o)
These mappings are mandatory and cannot be overridden at the entity/component level.

Supported shared options are:

The availability options.
The origin (required) options
command_topic
state_topic
qos
encoding
The component specific options are placed as mappings under the components key (abbreviated as cmps) like:

{
  "dev": {
    "ids": "ea334450945afc",
    "name": "Kitchen",
    "mf": "Bla electronics",
    "mdl": "xya",
    "sw": "1.0",
    "sn": "ea334450945afc",
    "hw": "1.0rev2"
  },
  "o": {
    "name":"bla2mqtt",
    "sw": "2.1",
    "url": "https://bla2mqtt.example.com/support"
  },
  "cmps": {
    "some_unique_component_id1": {
      "p": "sensor",
      "device_class":"temperature",
      "unit_of_measurement":"°C",
      "value_template":"{{ value_json.temperature}}",
      "unique_id":"temp01ae_t"
    },
    "some_unique_id2": {
      "p": "sensor",
      "device_class":"humidity",
      "unit_of_measurement":"%",
      "value_template":"{{ value_json.humidity}}",
      "unique_id":"temp01ae_h"
    }
  },
  "state_topic":"sensorBedroom/state",
  "qos": 2
}
JSON
The components id’s under the components (cmps) key, are used as part of the discovery identification. A platform (p) config option is required for each component config that is added to identify the component platform. Also required is a unique_id for entity-based components.

To remove the components, publish an empty (retained) string payload to the discovery topic. This will remove the component and clear the published discovery payload. It will also remove the device entry if there are no further references to it.

An empty config can be published as an update to remove a single component from the device discovery. Note that adding the platform (p) option is still required.

{
  "dev": {
    "ids": "ea334450945afc",
    "name": "Kitchen",
    "mf": "Bla electronics",
    "mdl": "xya",
    "sw": "1.0",
    "sn": "ea334450945afc",
    "hw": "1.0rev2"
  },
  "o": {
    "name":"bla2mqtt",
    "sw": "2.1",
    "url": "https://bla2mqtt.example.com/support"
  },
  "cmps": {
    "some_unique_component_id1": {
      "p": "sensor",
      "device_class":"temperature",
      "unit_of_measurement":"°C",
      "value_template":"{{ value_json.temperature}}",
      "unique_id":"temp01ae_t"
    },
    "some_unique_id2": {
      "p": "sensor"
    }
  },
  "state_topic":"sensorBedroom/state",
  "qos": 2
}
JSON
This will explicitly remove the humidity sensor and its entry.

After removing a component, you should send another update with the removed component omitted from the configuration. This ensures that Home Assistant has the most up-to-date device configuration. For example:

{
  "dev": {
    "ids": "ea334450945afc",
    "name": "Kitchen",
    "mf": "Bla electronics",
    "mdl": "xya",
    "sw": "1.0",
    "sn": "ea334450945afc",
    "hw": "1.0rev2"
  },
  "o": {
    "name":"bla2mqtt",
    "sw": "2.1",
    "url": "https://bla2mqtt.example.com/support"
  },
  "cmps": {
    "some_unique_component_id1": {
      "p": "sensor",
      "device_class":"temperature",
      "unit_of_measurement":"°C",
      "value_template":"{{ value_json.temperature}}",
      "unique_id":"temp01ae_t"
    }
  },
  "state_topic":"sensorBedroom/state",
  "qos": 2
}
JSON
A component config part in a device discovery payload must have the platform (p) option set with the name of the component and also must have at least one component specific config option. Entity components must have set the unique_id option and have a device context.

Migration from single component to device-based discovery 
To allow a smooth migration from single component discovery to device-based discovery:

Ensure all entities have a unique_id and a device context.
Move the object_id inside the discovery payload, if that is available, or use a unique ID or the component.
Consider using the previous node_id as the new object_id of the device discovery topic.
Ensure the unique_id matches and the device context has the correct identifiers.
Send the following payload to all existing single component discovery topics: {"migrate_discovery": true }. This will unload the discovered item, but its settings will be retained.
Switch the discovery topic to the device-based discovery topic and include all the component configurations.
Clean up the single component discovery messages with an empty payload.
During the migration steps, INFO messages will be logged to inform you about the progress of the migration.

 Important

Consider testing the migration process in a non-production environment before applying it to a live system.

Discovery migration example with a device automation and a sensor 
Step 1: Original single component discovery configurations:

Discovery topic single: homeassistant/device_automation/0AFFD2/bla1/config Discovery id: 0AFFD2 bla1 (both 0AFFD2 and bla1 from the discovery topic) Discovery payload single:

{
  "device": {
    "identifiers": ["0AFFD2"],
    "name": "Test device"
  },
  "o": {
    "name": "foobar"
  },
  "automation_type": "trigger",
  "payload": "short_press",
  "topic": "foobar/triggers/button1",
  "type": "button_short_press",
  "subtype": "button_1"
}
JSON
Discovery topic single: homeassistant/sensor/0AFFD2/bla2/config Discovery id: 0AFFD2 bla2 (both 0AFFD2 and bla2 from the discovery topic) Discovery payload single:

{
  "device": {
    "identifiers": ["0AFFD2"],
    "name": "Test device"
  },
  "o": {
    "name": "foobar"
  },
  "state_topic": "foobar/sensor/sensor1",
  "unique_id": "bla_sensor001"
}
JSON
Step 2: Initiate migration by publishing to both discovery topics:

When these single component discovery payloads are processed, and we want to initiate migration to a device-based discovery, we need to publish …

{"migrate_discovery": true }
JSON
… to both discovery topics …

homeassistant/device_automation/0AFFD2/bla1/config
homeassistant/sensor/0AFFD2/bla2/config
 Important

Check the logs to ensure this step is executed correctly.

Step 3: Publish the new device-based discovery configuration:

Discovery topic device: homeassistant/device/0AFFD2/config Discovery id: 0AFFD2 bla (0AFFD2from discovery topic, bla: The key under cmps in the discovery payload) Discovery payload device:

{
  "device": {
    "identifiers": [
      "0AFFD2"
    ]
  },
  "o": {
    "name": "foobar"
  },
  "cmps": {
    "bla1": {
      "p": "device_automation",
      "automation_type": "trigger",
      "payload": "short_press",
      "topic": "foobar/triggers/button1",
      "type": "button_short_press",
      "subtype": "button_1"
    },
    "bla2": {
      "p": "sensor",
      "state_topic": "foobar/sensor/sensor1",
      "unique_id": "bla_sensor001"
    }
  }
}
JSON
 Important

Check the logs to ensure the migration was successful.

Step 4: Clean up after successful migration:

After the logs show a successful migration, the single component discovery topics can be cleaned up safely by publishing an empty payload to them. The logs should indicate if the discovery migration was successful.

Optional: Rolling back the migration:

To rollback publish …

{"migrate_discovery": true }
JSON
To the device-based discovery topic(s). After that, re-publish the single component discovery payloads. At last, clean up the device-based discovery payloads by publishing an empty payload.

Check the logs for every step.

Single component discovery payload 
The <component> part in the discovery topic must be one of the supported MQTT-platforms. The options in the payload are only used to set up one specific component. If there are more components, more discovery payloads need to be sent for the other components, and it is then recommended to use device-based discovery instead.

Example discovery payload:

{
  "dev": {
    "ids": "ea334450945afc",
    "name": "Kitchen",
    "mf": "Bla electronics",
    "mdl": "xya",
    "sw": "1.0",
    "sn": "ea334450945afc",
    "hw": "1.0rev2"
  },
  "o": {
    "name":"bla2mqtt",
    "sw": "2.1",
    "url": "https://bla2mqtt.example.com/support"
  },
  "device_class":"temperature",
  "unit_of_measurement":"°C",
  "value_template":"{{ value_json.temperature}}",
  "unique_id":"temp01ae_t",
  "state_topic":"sensorBedroom/state",
  "qos": 2
}
JSON
To remove the component, publish an empty string to the discovery topic. This will remove the component and clear the published discovery payload. It will also remove the device entry if there are no further references to it.

For more examples see.

Discovery payload 
The payload must be a serialized JSON dictionary and will be checked like an entry in your configuration.yaml file if a new device is added, with the exception that unknown configuration keys are allowed but ignored. This means that missing variables will be filled with the integration’s default values. All configuration variables which are required must be present in the payload. The reason for allowing unknown documentation keys is allow some backwards compatibility, software generating MQTT discovery messages can then be used with older Home Assistant versions which will simply ignore new features.

A discovery payload can be sent with a retain flag set. In that case, the discovery message will be stored at the MQTT broker and processed automatically when the MQTT integrations start. This method removes the need for it to be resent. A better approach, though, is for the software generating MQTT discovery messages to send discovery payload(s) when the MQTT integration sends the Birth message.

Subsequent messages on a topic where a valid payload has been received will be handled as a configuration update, and a configuration update with an empty payload will cause a previously discovered device to be deleted.

A base topic ~ may be defined in the payload to conserve memory when the same topic base is used multiple times. In the value of configuration variables ending with _topic, ~ will be replaced with the base topic, if the ~ occurs at the beginning or end of the value.

Configuration variable names in the discovery payload may be abbreviated to conserve memory when sending a discovery message from memory constrained devices.

It is recommended to add information about the origin of MQTT entities by including the origin option (abbreviated as o) in the discovery payload. For device-based discovery, this information is required. The origin details will be logged in the core event log when an item is discovered or updated. Adding origin information helps with troubleshooting and provides valuable context about the source of MQTT messages in your Home Assistant setup.

Note: These options also support abbreviations, as shown in the table below.

name
The name of the application that is the origin of the discovered MQTT item. (Required)

sw_version
Software version of the application that supplies the discovered MQTT item.

support_url
Support URL of the application that supplies the discovered MQTT item.

Supported abbreviations in MQTT discovery messages 
Supported abbreviations
Supported abbreviations for device registry configuration
Supported abbreviations for origin info
Discovery messages and availability 
When MQTT discovery is set up, and a device or service sends a discovery message, an MQTT entity, tag, or device automation will be set up directly after receiving the message. When Home Assistant is restarting, discovered MQTT items with a unique ID will be unavailable until a new discovery message is received. MQTT items without a unique ID will not be added at startup. So a device or service using MQTT discovery must make sure a configuration message is offered after the MQTT integration has been (re)started. There are 2 common approaches to make sure the discovered items are set up at startup:

Using Birth and Will messages to trigger setup
Using retained messages
Finally, it is a best practice to publish your device or service availability status.

Use the Birth and Will messages to trigger discovery 
When the MQTT integration starts, a birth message is published at homeassistant/status by default. A device or service connected to the shared mqtt broker can subscribe to this topic and use an online message to trigger discovery messages. See also the birth and last will messages section. After the configs have been published, the state topics will need an update, so they need to be republished.

Using retained config messages 
An alternative method for a device or service is to publish discovery messages with a retain flag. This will make sure discovery messages are replayed when the MQTT integration connects to the broker. After the configs have been published, the state topics will need an update.

Using retained state messages 
State updates also need to be re-published after a config as been processed. This can also be done by publishing retained messages. As soon as a config is received (or replayed from a retained message), the setup will subscribe any state topics. If a retained message is available at a state topic, this message will be replayed so that the state can be restored for this topic.

 Warning

A disadvantage of using retained messages is that these messages retain at the broker, even when the device or service stops working. They are retained even after the system or broker has been restarted. Retained messages can create ghost entities that keep coming back.

Especially when you have many entities, (unneeded) discovery messages can cause excessive system load. For this reason, use discovery messages with caution.

Using Availability topics 
A device or service can announce its availability by publishing a Birth message and set a Will message at the broker. When the device or service loses connection to the broker, the broker will publish the Will message. This allows the MQTT integration to make an entity unavailable.

Platform specific availability settings are available for mqtt entity platforms only.

Platform specific availability settings
Discovery examples with component discovery 
Motion detection (binary sensor) 
A motion detection device which can be represented by a binary sensor for your garden would send its configuration as JSON payload to the Configuration topic. After the first message to config, then the MQTT messages sent to the state topic will update the state in Home Assistant.

Configuration topic: homeassistant/binary_sensor/garden/config
State topic: homeassistant/binary_sensor/garden/state
Configuration payload with derived device name:
{
   "name":null,
   "device_class":"motion",
   "state_topic":"homeassistant/binary_sensor/garden/state",
   "unique_id":"motion01ad",
   "device":{
      "identifiers":[
         "01ad"
      ],
      "name":"Garden"
   }
}
JSON
Retain: The -r switch is added to retain the configuration topic in the broker. Without this, the sensor will not be available after Home Assistant restarts.
It is also a good idea to add a unique_id to allow changes to the entity and a device mapping so we can group all sensors of a device together. We can set “name” to null if we want to inherit the device name for the entity. If we set an entity name, the friendly_name will be a combination of the device and entity name. If name is left away and a device_class is set, the entity name part will be derived from the device_class.

Example configuration payload with no name set and derived device_class name:
{
   "name":null,
   "device_class":"motion",
   "state_topic":"homeassistant/binary_sensor/garden/state",
   "unique_id":"motion01ad",
   "device":{
      "identifiers":[
         "01ad"
      ],
      "name":"Garden"
   }
}
JSON
If no name is set, a default name will be set by MQTT (see the MQTT platform documentation).

To create a new sensor manually and with the name set to null to derive the device name “Garden”:

mosquitto_pub -r -h 127.0.0.1 -p 1883 -t "homeassistant/binary_sensor/garden/config" -m '{"name": null, "device_class": "motion", "state_topic": "homeassistant/binary_sensor/garden/state", "unique_id": "motion01ad", "device": {"identifiers": ["01ad"], "name": "Garden" }}'
Bash
Update the state:

mosquitto_pub -h 127.0.0.1 -p 1883 -t "homeassistant/binary_sensor/garden/state" -m ON
Bash
Delete the sensor by sending an empty message.

mosquitto_pub -h 127.0.0.1 -p 1883 -t "homeassistant/binary_sensor/garden/config" -m ''
Bash
For more details please refer to the MQTT testing section.

Sensors 
Setting up a sensor with multiple measurement values requires multiple consecutive configuration topic submissions.

Configuration topic no1: homeassistant/sensor/sensorBedroomT/config
Configuration payload no1:
{
   "device_class":"temperature",
   "state_topic":"homeassistant/sensor/sensorBedroom/state",
   "unit_of_measurement":"°C",
   "value_template":"{{ value_json.temperature}}",
   "unique_id":"temp01ae",
   "device":{
      "identifiers":[
          "bedroom01ae"
      ],
      "name":"Bedroom",
      "manufacturer": "Example sensors Ltd.",
      "model": "Example Sensor",
      "model_id": "K9",
      "serial_number": "12AE3010545",
      "hw_version": "1.01a",
      "sw_version": "2024.1.0",
      "configuration_url": "https://example.com/sensor_portal/config"
   }
}
JSON
Configuration topic no2: homeassistant/sensor/sensorBedroomH/config
Configuration payload no2:
{
   "device_class":"humidity",
   "state_topic":"homeassistant/sensor/sensorBedroom/state",
   "unit_of_measurement":"%",
   "value_template":"{{ value_json.humidity}}",
   "unique_id":"hum01ae",
   "device":{
      "identifiers":[
         "bedroom01ae"
      ]
   }
}
JSON
The sensor identifiers or connections option allows to set up multiple entities that share the same device.

 Note

If a device configuration is shared, then it is not needed to add all device details to the other entity configs. It is enough to add shared identifiers or connections to the device mapping for the other entity config payloads.

A common state payload that can be parsed with the value_template in the sensor configs:

{
   "temperature":23.20,
   "humidity":43.70
}
JSON
Entities with command topics 
Setting up a light, switch etc. is similar but requires a command_topic as mentioned in the MQTT switch documentation.

Configuration topic: homeassistant/switch/irrigation/config
State topic: homeassistant/switch/irrigation/state
Command topic: homeassistant/switch/irrigation/set
Payload:
{
   "name":"Irrigation",
   "command_topic":"homeassistant/switch/irrigation/set",
   "state_topic":"homeassistant/switch/irrigation/state",
   "unique_id":"irr01ad",
   "device":{
      "identifiers":[
         "garden01ad"
      ],
      "name":"Garden"
   }
}
JSON
Retain: The -r switch is added to retain the configuration topic in the broker. Without this, the sensor will not be available after Home Assistant restarts.
mosquitto_pub -r -h 127.0.0.1 -p 1883 -t "homeassistant/switch/irrigation/config" \
  -m '{"name": "Irrigation", "command_topic": "homeassistant/switch/irrigation/set", "state_topic": "homeassistant/switch/irrigation/state", "unique_id": "irr01ad", "device": {"identifiers": ["garden01ad"], "name": "Garden" }}'
Bash
Set the state:

mosquitto_pub -h 127.0.0.1 -p 1883 -t "homeassistant/switch/irrigation/set" -m ON
Bash
Using abbreviations and base topic 
Setting up a switch using topic prefix and abbreviated configuration variable names to reduce payload length.

Configuration topic: homeassistant/switch/irrigation/config
Command topic: homeassistant/switch/irrigation/set
State topic: homeassistant/switch/irrigation/state
Configuration payload:
{
   "~":"homeassistant/switch/irrigation",
   "name":"garden",
   "cmd_t":"~/set",
   "stat_t":"~/state"
}
JSON
Another example using abbreviations topic name and base topic 
Setting up a light that takes JSON payloads, with abbreviated configuration variable names:

Configuration topic: homeassistant/light/kitchen/config

Command topic: homeassistant/light/kitchen/set

State topic: homeassistant/light/kitchen/state

Example state payload: {"state": "ON", "brightness": 255}

Configuration payload:

{
  "~": "homeassistant/light/kitchen",
  "name": "Kitchen",
  "uniq_id": "kitchen_light",
  "cmd_t": "~/set",
  "stat_t": "~/state",
  "schema": "json",
  "brightness": true
}
JSON
Example with using abbreviated Device and Origin info in discovery messages 
{
  "~": "homeassistant/light/kitchen",
  "name": null,
  "uniq_id": "kitchen_light",
  "cmd_t": "~/set",
  "stat_t": "~/state",
  "schema": "json",
  "dev": {
    "ids": "ea334450945afc",
    "name": "Kitchen",
    "mf": "Bla electronics",
    "mdl": "xya",
    "mdl_id": "ABC123",
    "sw": "1.0",
    "sn": "ea334450945afc",
    "hw": "1.0rev2"
  },
  "o": {
    "name":"bla2mqtt",
    "sw": "2.1",
    "url": "https://bla2mqtt.example.com/support"
  }
}
JSON
Use object_id to influence the entity ID 
The entity ID is automatically generated from the entity’s name. All MQTT integrations optionally support providing an object_id which will be used instead if provided.

Configuration topic: homeassistant/sensor/device1/config
Example configuration payload:
{
  "name":"My Super Device",
  "object_id":"my_super_device",
  "state_topic": "homeassistant/sensor/device1/state"
 }
JSON
In the example above, the entity_id will be sensor.my_super_device instead of sensor.device1.

Support by third-party tools 
The following software has built-in support for MQTT discovery:

ArduinoHA
Arilux AL-LC0X LED controllers
ble2mqtt
diematic_server
digitalstrom-mqtt
ebusd
ecowitt2mqtt
EMS-ESP32 (and EMS-ESP)
ESPHome
ESPurna
go-iotdevice
HASS.Agent
IOTLink (starting with 2.0.0)
MiFlora MQTT Daemon
MyElectricalData
MqDockerUp
Nuki Hub
Nuki Smart Lock 3.0 Pro, more info
OpenMQTTGateway
OTGateway
room-assistant (starting with 1.1.0)
SmartHome
SpeedTest-CLI MQTT
SwitchBot-MQTT-BLE-ESP32
Tasmota (starting with 5.11.1e, development halted)
TeddyCloud
Teleinfo MQTT (starting with 3.0.0)
Tydom2MQTT
What’s up Docker? (starting with 3.5.0)
WyzeSense2MQTT
Xiaomi DaFang Hacks
Zehnder Comfoair RS232 MQTT
Zigbee2MQTT
The following software also supports consuming MQTT discovery information that is intended for Home Assistant. Compatibility and features will vary, and not all devices may work.

Domoticz
openHAB
Manual configured MQTT items 
Support to allow adding manual items as a subentry via a config flow, is work in progress. Not all entity platforms are supported yet.

For most integrations, it is also possible to manually set up MQTT items in configuration.yaml. Read more about configuration in YAML.

MQTT supports two styles for configuring items in YAML. All configuration items are placed directly under the mqtt integration key. Note that you cannot mix these styles. Use the YAML configuration listed per item style when in doubt.

YAML configuration listed per item 
This method expects all items to be in a YAML list. Each item has a {domain} key and the item config is placed directly under the domain key. This method is considered as best practice. In all the examples we use this format.

mqtt:
  - {domain}:
      name: ""
      ...
  - {domain}:
      name: ""
      ...
YAML
YAML configuration keyed and bundled by {domain} 
All items are grouped per {domain} and where all configs are listed.

mqtt:
  {domain}:
    - name: ""
      ...
    - name: ""
      ...
YAML
If you have a large number of manually configured items, you might want to consider splitting up the configuration.

 Note

Documentation on the MQTT components that support YAML can be found here.

Entity state updates 
Entities receive state updates via MQTT subscriptions. The payloads received on the state topics are processed to determine whether there is a significant change. If a change is detected, the entity will be updated.

Note that MQTT device payloads often contain information for updating multiple entities that subscribe to the same topics. For example, a light status update might include information about link quality. This data can update a link quality sensor but is not used to update the light itself. MQTT filters out entity state updates when there are no changes.

The last reported state attribute 
Because MQTT state updates are often repeated frequently, even when no actual changes exist, it is up to the MQTT subscriber to determine whether a status update was received. If the latest update is missed, it might take some time before the next one arrives. If a retained payload exists at the broker, that value will be replayed first, but it will be an update of a previous last state.

MQTT devices often continuously generate numerous state updates. MQTT does not update last_reported to avoid impacting system stability unless force_update is set. Alternatively, an MQTT sensor can be created to measure the last update.

Using Templates 
The MQTT integration supports templating. Read more about using templates with the MQTT integration.

Examples 
REST API 
Using the REST API to send a message to a given topic.

$ curl -X POST \
    -H "Authorization: Bearer ABCDEFGH" \
    -H "Content-Type: application/json" \
    -d '{"payload": "Test message from HA", "topic": "home/notification"}' \
    http://IP_ADDRESS:8123/api/services/mqtt/publish
Bash
Automations 
Use as script in automations.

automation:
  alias: "Send me a message when I get home"
  triggers:
    - trigger: state
      entity_id: device_tracker.me
      to: "home"
  actions:
    - action: script.notify_mqtt
      data:
        target: "me"
        message: "I'm home"

script:
  notify_mqtt:
    sequence:
      - action: mqtt.publish
        data:
          payload: "{{ message }}"
          topic: home/"{{ target }}"
          retain: true
YAML
Publish & Dump actions 
The MQTT integration will register the mqtt.publish action, which allows publishing messages to MQTT topics.

Action mqtt.publish 
Data attribute	Optional	Description
topic	no	Topic to publish payload to.
payload	yes	Payload to publish. Will publish an empty payload when payload is omitted.
evaluate_payload	yes	If a bytes literal in payload should be evaluated to publish raw data. (default: false)
qos	yes	Quality of Service to use. (default: 0)
retain	yes	If message should have the retain flag set. (default: false)
 Note

When payload is rendered from template in a YAML script or automation, and the template renders to a bytes literal, the outgoing MQTT payload will only be sent as raw data, if the evaluate_payload option flag is set to true.

topic: homeassistant/light/1/command
payload: on
YAML
topic: homeassistant/light/1/state
payload: "{{ states('device_tracker.paulus') }}"
YAML
topic: "homeassistant/light/{{ states('sensor.light_active') }}/state"
payload: "{{ states('device_tracker.paulus') }}"
YAML
Be aware that payload must be a string. If you want to send JSON using the YAML editor then you need to format/escape it properly. Like:

topic: homeassistant/light/1/state
payload: "{\"Status\":\"off\", \"Data\":\"something\"}"`
YAML
The example below shows how to publish a temperature sensor ‘Bathroom Temperature’. The device_class is set, so it is not needed to set the “name” option. The entity will inherit the name from the device_class set and also support translations. If you set “name” in the payload the entity name will start with the device name.

action: mqtt.publish
data:
  topic: homeassistant/sensor/Acurite-986-1R-51778/config
  payload: >-
    {"device_class": "temperature",
    "unit_of_measurement": "\u00b0C",
    "value_template": "{{ value|float }}",
    "state_topic": "rtl_433/rtl433/devices/Acurite-986/1R/51778/temperature_C",
    "unique_id": "Acurite-986-1R-51778-T",
    "device": {
    "identifiers": "Acurite-986-1R-51778",
    "name": "Bathroom",
    "model": "Acurite",
    "model_id": "986",
    "manufacturer": "rtl_433" }
    }
YAML
Example of how to use qos and retain:

topic: homeassistant/light/1/command
payload: on
qos: 2
retain: true
YAML
Action mqtt.dump 
Listen to the specified topic matcher and dumps all received messages within a specific duration into the file mqtt_dump.txt in your configuration folder. This is useful when debugging a problem.

Data attribute	Optional	Description
topic	no	Topic to dump. Can contain a wildcard (# or +).
duration	yes	Duration in seconds that we will listen for messages. Default is 5 seconds.
topic: zigbee2mqtt/#
YAML
Logging 
The logger integration allows the logging of received MQTT messages.

# Example configuration.yaml entry
logger:
  default: warning
  logs:
    homeassistant.components.mqtt: debug
YAML
Event event_mqtt_reloaded 
Event event_mqtt_reloaded is fired when Manually configured MQTT entities have been reloaded and entities thus might have changed.

This event has no additional data.

Removing the integration 
Go to Settings > Devices & services and select the integration card.
From the list of devices, select the integration instance you want to remove.
Next to the entry, select the three dots  menu. Then, select Delete.
Note: This action does not remove the MQTT broker or its data. If you want to completely remove MQTT:

Check your configuration.yaml and other YAML files for MQTT-related configurations and remove them
Review your automations and scripts for any MQTT dependencies
Consider backing up your configuration before making these changes
 Help us improve our documentation
Suggest an edit to this page, or provide/view feedback for this page.


# MQTT Cover
The mqtt cover platform allows you to control an MQTT cover (such as blinds, a roller shutter or a garage door).

Configuration 
A cover entity can be in states (open, opening, closed or closing).

If a state_topic is configured, the entity’s state will be updated only after an MQTT message is received on state_topic matching state_open, state_opening, state_closed or state_closing. For covers that only report 3 states (opening, closing, stopped), a state_stopped state can be configured to indicate that the device is not moving. When this payload is received on the state_topic, and a position_topic is not configured, the cover will be set to state closed if its state was closing and to state open otherwise. If a position_topic is set, the cover’s position will be used to set the state to either open or closed state.

If the cover reports its position, a position_topic can be configured for receiving the position. If no state_topic is configured, the cover’s state will be set to either open or closed when a position is received.

If the cover reports its tilt position, a tilt_status_topic can be configured for receiving the tilt position. If position topic and state topic are both defined, the device state (open, opening, closed or closing) will be set by the state topic and the cover position will be set by the position topic.

If neither a state topic nor a position topic are defined, the cover will work in optimistic mode. In this mode, the cover will immediately change state (open or closed) after every command sent by Home Assistant. If a state topic/position topic is defined, the cover will wait for a message on state_topic or position_topic.

Optimistic mode can be forced, even if a state_topic / position_topic is defined. Try to enable it if experiencing incorrect cover operation (Google Assistant gauge may need optimistic mode as it often send request to your Home Assistant immediately after send set_cover_position in which case MQTT could be too slow).

The mqtt cover platform optionally supports a list of availability topics to receive online and offline messages (birth and LWT messages) from the MQTT cover device. During normal operation, if the MQTT cover device goes offline (i.e., publishes a matching payload_not_available to any availability topic), Home Assistant will display the cover as “unavailable”. If these messages are published with the retain flag set, the cover will receive an instant update after subscription and Home Assistant will display correct availability state of the cover when Home Assistant starts up. If the retain flag is not set, Home Assistant will display the cover as “unavailable” when Home Assistant starts up.

To use an MQTT cover in your installation, add a MQTT device as a subentry, or add the following to your configuration.yaml file. After changing the configuration.yaml file, restart Home Assistant to apply the changes.

# Example configuration.yaml entry
mqtt:
  - cover:
      command_topic: "living-room-cover/set"
YAML
Alternatively, a more advanced approach is to set it up via MQTT discovery.

Configuration Variables 
Looking for your configuration file?
availability list (Optional)
A list of MQTT topics subscribed to receive availability (online/offline) updates. Must not be used together with availability_topic.

payload_available string (Optional, default: online)
The payload that represents the available state.

payload_not_available string (Optional, default: offline)
The payload that represents the unavailable state.

topic string Required
An MQTT topic subscribed to receive availability (online/offline) updates.

value_template template (Optional)
Defines a template to extract device’s availability from the topic. To determine the devices’s availability result of this template will be compared to payload_available and payload_not_available.

availability_mode string (Optional, default: latest)
When availability is configured, this controls the conditions needed to set the entity to available. Valid entries are all, any, and latest. If set to all, payload_available must be received on all configured availability topics before the entity is marked as online. If set to any, payload_available must be received on at least one configured availability topic before the entity is marked as online. If set to latest, the last payload_available or payload_not_available received on any configured availability topic controls the availability.

availability_template template (Optional)
Defines a template to extract device’s availability from the availability_topic. To determine the devices’s availability result of this template will be compared to payload_available and payload_not_available.

availability_topic string (Optional)
The subscribed-to MQTT topic to receive birth and LWT messages from the MQTT cover device. If an availability topic is not defined, the cover availability state will always be available. If an availability topic is defined, the cover availability state will be unavailable by default. Must not be used together with availability.

command_topic string (Optional)
The MQTT topic to publish commands to control the cover.

default_entity_id string (Optional)
Use default_entity_id instead of name for automatic generation of the entity ID. For example, cover.foobar. When used without a unique_id, the entity ID will update during restart or reload if the entity ID is available. If the entity ID already exists, the entity ID will be created with a number at the end. When used with a unique_id, the default_entity_id is only used when the entity is added for the first time. When set, this overrides a user-customized entity ID if the entity was deleted and added again.

device map (Optional)
Information about the device this cover is a part of to tie it into the device registry. Only works when unique_id is set. At least one of identifiers or connections must be present to identify the device.

configuration_url string (Optional)
A link to the webpage that can manage the configuration of this device. Can be either an http://, https:// or an internal homeassistant:// URL.

connections list (Optional)
A list of connections of the device to the outside world as a list of tuples [connection_type, connection_identifier]. For example the MAC address of a network interface: "connections": [["mac", "02:5b:26:a8:dc:12"]].

hw_version string (Optional)
The hardware version of the device.

identifiers list | string (Optional)
A list of IDs that uniquely identify the device. For example a serial number.

manufacturer string (Optional)
The manufacturer of the device.

model string (Optional)
The model of the device.

model_id string (Optional)
The model identifier of the device.

name string (Optional)
The name of the device.

serial_number string (Optional)
The serial number of the device.

suggested_area string (Optional)
Suggest an area if the device isn’t in one yet.

sw_version string (Optional)
The firmware version of the device.

via_device string (Optional)
Identifier of a device that routes messages between this device and Home Assistant. Examples of such devices are hubs, or parent devices of a sub-device. This is used to show device topology in Home Assistant.

device_class string (Optional)
Sets the class of the device, changing the device state and icon that is displayed on the frontend. The device_class can be null.

enabled_by_default boolean (Optional, default: true)
Flag which defines if the entity should be enabled when first added.

encoding string (Optional, default: utf-8)
The encoding of the payloads received and published messages. Set to "" to disable decoding of incoming payload.

entity_category string (Optional)
The category of the entity.

entity_picture string (Optional)
Picture URL for the entity.

icon icon (Optional)
Icon for the entity.

json_attributes_template template (Optional)
Defines a template to extract the JSON dictionary from messages received on the json_attributes_topic. Usage example can be found in MQTT sensor documentation.

json_attributes_topic string (Optional)
The MQTT topic subscribed to receive a JSON dictionary payload and then set as sensor attributes. Usage example can be found in MQTT sensor documentation.

name string (Optional, default: MQTT Cover)
The name of the cover. Can be set to null if only the device name is relevant.

optimistic boolean (Optional)
Flag that defines if switch works in optimistic mode.

Default: false if state or position topic defined, else true.
payload_available string (Optional, default: online)
The payload that represents the online state.

payload_close string (Optional, default: CLOSE)
The command payload that closes the cover.

payload_not_available string (Optional, default: offline)
The payload that represents the offline state.

payload_open string (Optional, default: OPEN)
The command payload that opens the cover.

payload_stop string (Optional, default: STOP)
The command payload that stops the cover.

payload_stop_tilt string (Optional, default: stop)
The command payload that stops the tilt.

platform string Required
Must be cover. Only allowed and required in MQTT auto discovery device messages.

position_closed integer (Optional, default: 0)
Number which represents closed position.

position_open integer (Optional, default: 100)
Number which represents open position.

position_template template (Optional)
Defines a template that can be used to extract the payload for the position_topic topic. Within the template the following variables are available: entity_id, position_open; position_closed; tilt_min; tilt_max. The entity_id can be used to reference the entity’s attributes with help of the states template function;

position_topic string (Optional)
The MQTT topic subscribed to receive cover position messages.

qos integer (Optional, default: 0)
The maximum QoS level to be used when receiving and publishing messages.

retain boolean (Optional, default: false)
Defines if published messages should have the retain flag set.

set_position_template template (Optional)
Defines a template to define the position to be sent to the set_position_topic topic. Incoming position value is available for use in the template {{ position }}. Within the template the following variables are available: entity_id, position, the target position in percent; position_open; position_closed; tilt_min; tilt_max. The entity_id can be used to reference the entity’s attributes with help of the states template function;

set_position_topic string (Optional)
The MQTT topic to publish position commands to. You need to set position_topic as well if you want to use position topic. Use template if position topic wants different values than within range position_closed - position_open. If template is not defined and position_closed != 100 and position_open != 0 then proper position value is calculated from percentage position.

state_closed string (Optional, default: closed)
The payload that represents the closed state.

state_closing string (Optional, default: closing)
The payload that represents the closing state.

state_open string (Optional, default: open)
The payload that represents the open state.

state_opening string (Optional, default: opening)
The payload that represents the opening state.

state_stopped string (Optional, default: stopped)
The payload that represents the stopped state (for covers that do not report open/closed state).

state_topic string (Optional)
The MQTT topic subscribed to receive cover state messages. State topic can only read a (open, opening, closed, closing or stopped) state. A “None” payload resets to an unknown state. An empty payload is ignored.

tilt_closed_value integer (Optional, default: 0)
The value that will be sent on a close_cover_tilt command.

tilt_command_template template (Optional)
Defines a template that can be used to extract the payload for the tilt_command_topic topic. Within the template the following variables are available: entity_id, tilt_position, the target tilt position in percent; position_open; position_closed; tilt_min; tilt_max. The entity_id can be used to reference the entity’s attributes with help of the states template function;

tilt_command_topic string (Optional)
The MQTT topic to publish commands to control the cover tilt.

tilt_max integer (Optional, default: 100)
The maximum tilt value.

tilt_min integer (Optional, default: 0)
The minimum tilt value.

tilt_opened_value integer (Optional, default: 100)
The value that will be sent on an open_cover_tilt command.

tilt_optimistic boolean (Optional)
Flag that determines if tilt works in optimistic mode.

Default: true if tilt_status_topic is not defined, else false
tilt_status_template template (Optional)
Defines a template that can be used to extract the payload for the tilt_status_topic topic. Within the template the following variables are available: entity_id, position_open; position_closed; tilt_min; tilt_max. The entity_id can be used to reference the entity’s attributes with help of the states template function;

tilt_status_topic string (Optional)
The MQTT topic subscribed to receive tilt status update values.

unique_id string (Optional)
An ID that uniquely identifies this cover. If two covers have the same unique ID, Home Assistant will raise an exception. Required when used with device-based discovery.

value_template template (Optional)
Defines a template that can be used to extract the payload for the state_topic topic.

 Note

MQTT cover expects position and tilt values to be in range of 0 to 100, where 0 indicates closed position and 100 indicates fully open position. If position min or max are set to a different range (e.g. 40 to 140), when sending command to the device the range will be adjusted to the device range (position 0 will send a value of 40 to device) and when position payload is received from the device it will be adjusted back to the 0 to 100 range (device value of 40 will report cover position 0). min and max can also be used to reverse the direction of the device, if min is set to 100 and max is set to 0 device operation will be inverted (e.g. when setting position to 40, a value of 60 will be sent to device).

Examples 
In this section you will find some real-life examples of how to use this platform.

Full configuration state topic without tilt 
The example below shows a full configuration for a cover without tilt with state topic only.

# Example configuration.yaml entry
mqtt:
  - cover:
      name: "MQTT Cover"
      command_topic: "living-room-cover/set"
      state_topic: "living-room-cover/state"
      availability:
        - topic: "living-room-cover/availability"
      qos: 0
      retain: true
      payload_open: "OPEN"
      payload_close: "CLOSE"
      payload_stop: "STOP"
      state_open: "open"
      state_opening: "opening"
      state_closed: "closed"
      state_closing: "closing"
      payload_available: "online"
      payload_not_available: "offline"
      optimistic: false
      value_template: "{{ value.x }}"
YAML
Full configuration position topic without tilt 
The example below shows a full configuration for a cover without tilt with position topic.

# Example configuration.yaml entry
mqtt:
  - cover:
      name: "MQTT Cover"
      command_topic: "living-room-cover/set"
      position_topic: "living-room-cover/position"
      availability:
        - topic: "living-room-cover/availability"
      set_position_topic: "living-room-cover/set_position"
      qos: 0
      retain: true
      payload_open: "OPEN"
      payload_close: "CLOSE"
      payload_stop: "STOP"
      position_open: 100
      position_closed: 0
      payload_available: "online"
      payload_not_available: "offline"
      optimistic: false
      value_template: "{{ value.x }}"
YAML
Full configuration for position, state and tilt 
The example below shows a full configuration for a cover with position, state & tilt.

# Example configuration.yaml entry
mqtt:
  - cover:
      name: "MQTT Cover"
      command_topic: "living-room-cover/set"
      state_topic: "living-room-cover/state"
      position_topic: "living-room-cover/position"
      availability:
        - topic: "living-room-cover/availability"
      qos: 0
      retain: true
      payload_open: "OPEN"
      payload_close: "CLOSE"
      payload_stop: "STOP"
      state_open: "open"
      state_opening: "opening"
      state_closed: "closed"
      state_closing: "closing"
      payload_available: "online"
      payload_not_available: "offline"
      optimistic: false
      value_template: "{{ value.x }}"
      position_template: "{{ value.y }}"
      tilt_command_topic: "living-room-cover/tilt"
      tilt_status_topic: "living-room-cover/tilt-state"
      tilt_status_template: "{{ value_json["PWM"]["PWM1"] }}"
      tilt_min: 0
      tilt_max: 180
      tilt_closed_value: 70
      tilt_opened_value: 180
YAML
Full configuration using stopped state 
The example below shows a full configuration for a cover using stopped state.

# Example configuration.yaml entry
mqtt:
  - cover:
      name: "MQTT Cover"
      command_topic: "living-room-cover/set"
      state_topic: "living-room-cover/state"
      position_topic: "living-room-cover/position"
      availability:
        - topic: "living-room-cover/availability"
      qos: 0
      retain: true
      payload_open: "OPEN"
      payload_close: "CLOSE"
      payload_stop: "STOP"
      state_opening: "opening"
      state_closed: "closed"
      state_stopped: "stopped"
      payload_available: "online"
      payload_not_available: "offline"
      optimistic: false
      value_template: "{{ value.x }}"
      position_template: "{{ value.y }}"
YAML
Configuration for disabling cover commands 
The example below shows a configuration for a cover that does not have a close command. Setting payload_close empty or to null disables the close command and will not show the close button.

# Example configuration.yaml entry
mqtt:
  - cover:
      payload_open: "on"
      payload_close:
      payload_stop: "on"
YAML
The following commands can be disabled: open, close, stop by overriding their payloads: payload_open, payload_close, payload_stop

For auto discovery message the payload needs to be set to null, example for cover without close command:

{
  "cover": [
    {
      "payload_open": "on",
      "payload_close": null,
      "payload_stop": "on"
    }
  ]
}
JSON
Full configuration using entity_id- variable in the template 
The example below shows an example of how to correct the state of the blind depending if it moved up, or down.

# Example configuration.yaml entry
mqtt:
  - cover:
      name: "MQTT Cover"
      command_topic: "living-room-cover/set"
      state_topic: "living-room-cover/state"
      position_topic: "living-room-cover/position"
      set_position_topic: "living-room-cover/position/set"
      payload_open:  "open"
      payload_close: "close"
      payload_stop:  "stop"
      state_opening: "open"
      state_closing: "close"
      state_stopped: "stop"
      optimistic: false
      position_template: |-
        {% if not state_attr(entity_id, "current_position") %}
          {{ value }}
        {% elif state_attr(entity_id, "current_position") < (value | int) %}
          {{ (value | int + 1) }}
        {% elif state_attr(entity_id, "current_position") > (value | int) %}
          {{ (value | int - 1) }}
        {% else %}
          {{ value }}
        {% endif %}
YAML
Full configuration using advanced templating 
The position_template can accept JSON, where position and tilt_position is provided at the same time.

The example below shows a full example of how to set up a venetian blind which has a combined position and tilt topic. The blind in the example has moveable slats which tilt with a position change. In the example, it takes the blind 6% of the movement for a full rotation of the slats.

Following variable might be used in position_template, set_position_template, tilt_command_template and tilt_status_template, json_attributes_template (only entity_id).

entity_id - The ID of the entity itself. It can be used to reference its attributes with the help of the states template function.
position_open
position_closed
tilt_min
tilt_max
# Example configuration.yaml entry
mqtt:
  - cover:
      name: "MQTT Cover"
      command_topic: "living-room-cover/set"
      state_topic: "living-room-cover/state"
      position_topic: "living-room-cover/position"
      set_position_topic: "living-room-cover/position/set"
      tilt_command_topic: "living-room-cover/position/set" # same as `set_position_topic`
      qos: 1
      retain: false
      payload_open:  "open"
      payload_close: "close"
      payload_stop:  "stop"
      state_opening: "open"
      state_closing: "close"
      state_stopped: "stop"
      position_open: 100
      position_closed: 0
      tilt_min: 0
      tilt_max: 6
      tilt_opened_value: 3
      tilt_closed_value: 0
      optimistic: false
      position_template: |-
        {% if not state_attr(entity_id, "current_position") %}
          {
            "position" : {{ value }},
            "tilt_position" : 0
          }
        {% else %}
          {% set old_position = state_attr(entity_id, "current_position") %}
          {% set old_tilt_percent = (state_attr(entity_id, "current_tilt_position")) %}

          {% set movement = value | int - old_position %}
          {% set old_tilt_position = (old_tilt_percent / 100 * (tilt_max - tilt_min)) %}
          {% set new_tilt_position = min(max((old_tilt_position + movement), tilt_min), tilt_max) %}

          {
            "position": {{ value }},
            "tilt_position": {{ new_tilt_position }}
          }
        {% endif %}
    tilt_command_template: >-
        {% set position = state_attr(entity_id, "current_position") %}
        {% set tilt = state_attr(entity_id, "current_tilt_position") %}
        {% set movement = (tilt_position - tilt) / 100 * tilt_max %}
        {{ position + movement }}
      payload_open: "on"
      payload_close:
      payload_stop: "on"
YAML
Testing your configuration 
To test, you can use the command line tool mosquitto_pub shipped with mosquitto or the mosquitto-clients package to send MQTT messages. This allows you to operate your cover manually:

mosquitto_pub -h 127.0.0.1 -t living-room-cover/set -m "CLOSE"
Bash
 Help us improve our documentation
Suggest an edit to this page, or provide/view feedback for this page.